---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${SERVICE_NAME}
  namespace: ${NAMESPACE}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${SERVICE_NAME}
  template:
    metadata:
      labels:
        app: ${SERVICE_NAME}
    spec:
      initContainers:
        - name: init-wait-db
          image: busybox
          command: ['sh', '-c', 'for i in $(seq 1 300); do nc -zvw1 shared-database 5432 && exit 0 || sleep 3; done; exit 1']
      containers:
        - image: ${IMAGE_NAME}
          name: ${SERVICE_NAME}
          envFrom:
            - configMapRef:
                name: ${SERVICE_NAME}-config
          env:
#            Import variables from vault
            - name: S2S_KEY
              value: '${S2S_TOKEN}'
#            Import from main.tf
#            This is to use the postgres database that we create further down.
            - name: POSTGRES_HOST
              value: 'shared-database'
            - name: POSTGRES_DATABASE
              value: 'emannotationapp'
            - name: POSTGRES_USER
              value: 'emannotationapp'
            - name: POSTGRES_PASSWORD
              value: 'emannotationapp'
#           App insights
#           Note: value found in vault
            - name: APPINSIGHTS_INSTRUMENTATIONKEY
              value: '${APPINSIGHTS_INSTRUMENTATIONKEY}'
#            db
            - name: SPRING_DATASOURCE_URL
              value: 'jdbc:postgresql://shared-database:5432/emannotationapp?ssl=true'
            - name: SPRING_DATASOURCE_USERNAME
              value: 'emannotationapp'
            - name: SPRING_DATASOURCE_PASSWORD
              value: 'emannotationapp'
            - name: ENABLE_DB_MIGRATE
              value: 'true'
            - name: REFORM_SERVICE_NAME
              value: 'em-anno' # See em_anno_app_url in variables.tf
            - name: REFORM_TEAM
              value: 'evidence'
            - name: REFORM_SERVICE_TYPE
              value: 'java'
            - name: REFORM_ENVIRONMENT
              value: 'preview'
            - name: PACKAGES_NAME
              value: 'em-anno'
            - name: PACKAGES_PROJECT
              value: 'evidence'
            - name: PACKAGES_ENVIRONMENT
              value: 'preview'
            - name: ROOT_APPENDER
              value: 'JSON_CONSOLE'
            - name: JSON_CONSOLE_PRETTY_PRINT
              value: 'false'
            - name: LOG_OUTPUT
              value: 'single'
            - name: ROOT_LOGGING_LEVEL
              value: 'INFO'
            - name: LOG_LEVEL_SPRING_WEB
              value: 'INFO'
            - name: LOG_LEVEL_DM
              value: 'INFO'
            - name: SHOW_SQL
              value: 'true'
            - name: ENDPOINTS_HEALTH_SENSITIVE
              value: 'false'
            - name: ENDPOINTS_INFO_SENSITIVE
              value: 'false'
            - name: S2S_NAMES_WHITELIST
              value: 'em_api,em_gw,ccd_gw,ccd_data,sscs,divorce_document_upload,divorce_document_generator,probate_backend,jui_webapp,pui_webapp,em_npa_app'
            - name: CASE_WORKER_ROLES
              value: 'caseworker-probate,caseworker-cmc,caseworker-sscs,caseworker-divorce'
            - name: ENABLE_IDAM_HEALTH_CHECK
              value: 'false'
            - name: ENABLE_S2S_HEALTH_CHECK
              value: 'false'

##            This is to use a postgreSQL container (for PRs). TODO Set this and required associated resources up. What is secretKeyRef?!
#             START OF POSTGRES DB STUFF
#            - name: POSTGRES_HOST
#              valueFrom:
#                secretKeyRef:
#                  name: ${SERVICE_NAME}-postgres-secret
#                  key: host
#            - name: POSTGRES_DATABASE
#              valueFrom:
#                secretKeyRef:
#                  name: ${SERVICE_NAME}-postgres-secret
#                  key: database
#            - name: POSTGRES_USER
#              valueFrom:
#                secretKeyRef:
#                  name: ${SERVICE_NAME}-postgres-secret
#                  key: username
#            - name: POSTGRES_PASSWORD
#              valueFrom:
#                secretKeyRef:
#                  name: ${SERVICE_NAME}-postgres-secret
#                  key: password

#          PAUSE POSTGRES DB STUFF
          resources:
            requests:
              memory: '1024Mi'
              cpu: '200m'
            limits:
              memory: '2048Mi'
              cpu: '2500m'
          ports:
            - containerPort: 4400
              name: http
          imagePullPolicy: Always

#---
## TODO find out how much of this is needed for a postgres container, and how much I already have
# MORE POSTGRES DB STUFF
##
## Service Catalog Database Instance
##
#apiVersion: servicecatalog.k8s.io/v1beta1
#kind: ServiceInstance
#metadata:
#  name: ${SERVICE_NAME}-postgres-instance
#  namespace: ${NAMESPACE}
#spec:
#  #
#  # Get the value of this from 'svcat get classes'
#  #
#  clusterServiceClassExternalName: azure-postgresql-9-6-database
#
#  #
#  # The 'SKU'. Get the value of this from 'svc describe class <class name>'
#  #
#  clusterServicePlanExternalName: database
#
#  #
#  # Parameters.  Get these from here: https://github.com/Azure/open-service-broker-azure/blob/master/docs/modules/postgresql.md
#  # or 'svcat describe <class>/<plan>'
#  # e.g. 'svcat describe plan azure-postgresql-9-6-database/database'
#  #
#  parameters:
#    parentAlias: cnp-osba-postgres-server
#---
##
## The binding.  This will return the secret with connection details, etc.
##
#apiVersion: servicecatalog.k8s.io/v1beta1
#kind: ServiceBinding
#metadata:
#  name: ${SERVICE_NAME}-postgres-binding
#  namespace: ${NAMESPACE}
#spec:
#  instanceRef:
#    name: ${SERVICE_NAME}-postgres-instance
#  #
#  # This is the secret used above in your pod environment config
#  #
#  secretName: ${SERVICE_NAME}-postgres-secret

# END OF POSTGRES DB STUFF
---
#
# Service
#
apiVersion: v1
kind: Service
metadata:
  name: ${SERVICE_NAME}
  namespace: ${NAMESPACE}
  labels:
    app: ${SERVICE_NAME}
spec:
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 4400
  selector:
    app: ${SERVICE_NAME}
---
#
# INGRESS
#
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ${SERVICE_NAME}
  namespace: ${NAMESPACE}
  annotations:
    kubernetes.io/ingress.class: traefik
spec:
  rules:
    - host: ${SERVICE_FQDN}
      http:
        paths:
          - path: /
            backend:
              serviceName: ${SERVICE_NAME}
              servicePort: 80
---
#
# DATABASE
#
apiVersion: v1
kind: ConfigMap
metadata:
  name: shared-database-initdb
  namespace: ${NAMESPACE}
data:
  initdb.sql: |
    CREATE USER emannotationapp WITH PASSWORD 'emannotationapp';
    CREATE DATABASE emannotationapp WITH OWNER = emannotationapp ENCODING = 'UTF-8' CONNECTION LIMIT = -1;
#    APPINSIGHTS_INSTRUMENTATIONKEY: 'fake-key' #TODO: CMC-claim-store has this line, is it a placeholder that we actually need?

---
apiVersion: v1
kind: Namespace
metadata:
  name: ${NAMESPACE}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: shared-database
  namespace: ${NAMESPACE}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: shared-database
  template:
    metadata:
      labels:
        app: shared-database
    spec:
      containers:
        - image: postgres:10.5-alpine
          name: shared-database
          resources:
            requests:
              memory: '256Mi'
              cpu: '200m'
            limits:
              memory: '1024Mi'
              cpu: '1000m'
          imagePullPolicy: Always
          ports:
            - containerPort: 5432
              name: postgres
          volumeMounts:
            - mountPath: /docker-entrypoint-initdb.d
              name: initdb
              readOnly: true
      volumes:
        - name: initdb
          configMap:
            name: shared-database-initdb
---
apiVersion: v1
kind: Service
metadata:
  name: shared-database
  namespace: ${NAMESPACE}
  labels:
    app: shared-database
spec:
  ports:
    - port: 5432
  selector:
    app: shared-database
  clusterIP: None
